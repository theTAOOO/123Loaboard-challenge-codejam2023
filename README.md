# 123Loaboard-challenge-codejam2023
Inspiration
The reliability and ease of use of Uber was one of our main inspiration. Jack is also a pretty awe-inspiring person.

## What it does
Truckers can use our website to easily get tasked to deliver payloads. Once they open the app, they are instantly greeted with a map with markers of the loads, where one of the loads would be highlighted to them. Everything is already calculated and taken into consideration in the background, and all they have to do is to confirm the order by clicking on the highlighted marker.

## How we built it
We had React frontend with a Flask-SocketIO backend. Our backend also comprised a Paho-MQTT client to receive updates from the 123LoadBoard server.

The main functionality is wrapped into a GlobalController class with comprises a LogisticsOptimizer, MessageHandler, MQTTController, ReactController, LoadBank, and TruckBank instance respectively.

The LogisticsOptimizer class wraps the calculation and filtering of which trucks to notify upon a new load and which loads to send to a new truck.

The MessageHandler class wraps IO with the MQTTController, ReactController, and the running backend instance. For example, when the MQTTController receives a new load, the message is first passed to the MessageHandler instance which routes it to the appropriate load_received handler, which would then call the LogisticsOptimizer instance to get a list of trucks to notify. For each truck in that list, a call is made back to the MQTTController to create a new NTF message to send to the truck client, which is then passed to the ReactController to send to the React frontend.

As their names imply, MQTTController, ReactController respectively wrap the connections to the 123LoadBoard server (which uses the MQTT protocol) and our React frontend, which emulates a specific truck for demo purposes.

Finally, LoadBank and TruckBank respectively wrap the daily list of available loads and trucks. For example, upon receiving a new truck message from the MQTTController, the TruckBank will add a new truck (or update an existing truck) to its list.

## Challenges we ran into
We don't really know how to code so all of this was quite new to us. Implementation-wise, some API docs were easier to read through than others, and handling emergent complexity from implementation, such as having to create separate threads for the ReactController and the rest of GlobalController, was our biggest challenge. This is our first exposure to React, and implementing the Google Maps API was quite a notable learning experience.

Oh and, as usual, naming things was particularly arduous.

## Accomplishments that we're proud of
As mentioned, we don't really know how to code, so we're proud of ourselves for all the learning we did. Some of us were not really familiar with the handling of APIs, and we were able to generate a key for Google Maps API in order to calculate the path distance between two coordinates. As mentioned in the challenges we faced, none of us were familiar with the front end part of development, so learning everything from scratch is an accomplishment we can be proud of.

## What we learned
What didn't we?

## What's next for SwiftTrack
To us, making a robust and reliable product is more important than adding fancy features with dubious scalability. As such, we would first work on things like securing our connections to the frontend Trucker client and to the Trucker/Load dispatch server, creating a database to store our pools of Trucker and Loads, and sanitizing our messaging to avoid race conditions were, say, a number of truckers request to pick up the same load at once, or the list of truckers/loads are modified as we loop through them.

With that aside, some nice-to-haves would be to implement a history tab where truckers can view and contemplate their past deliveries, or to display the hourly profit generated by a load if the trucker were to pick it up.

Built With
flask
python
react
websockets
